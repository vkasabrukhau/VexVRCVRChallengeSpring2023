{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vrc import *\nfrom vexcode_vrc.events import get_Task_func\n  \n# constructors\n\ndrivetrain = Drivetrain()\nbrain = Brain()\nbottom_distance = Distance(\"BottomDistance\", 18)\nroller_optical = Optical(\"RollerOptical\", 2)\ngps = GPS(\"GPS\", 3)\nintake_motor_group = Motor(\"IntakeMotorGroup\", 10)\nbottom_line_tracker = LineTracker(\"BottomLineTracker\", 22)\nmiddle_line_tracker = LineTracker(\"MiddleLineTracker\", 23)\ntop_line_tracker = LineTracker(\"TopLineTracker\", 24)\n#endregion VEXcode Generated Robot Configuration\nvexcode_brain_precision = 0\nAngle = 0\nAimAdjust = 0\nRedGoalDistance = 0\nBlueGoalDistance = 0\nStorage = 0\nDiscs = [0 for x in range(3)]\nScanner = [0 for x in range(2)]\nRollerTracker = [0 for x in range(2)]\n\ndef Seek_Intake_X_Y_FireDiscs_Pickup(Seek_Intake_X_Y_FireDiscs_Pickup__X, Seek_Intake_X_Y_FireDiscs_Pickup__Y, Seek_Intake_X_Y_FireDiscs_Pickup__FireDiscs, Seek_Intake_X_Y_FireDiscs_Pickup__Pickup):\n    global Angle, AimAdjust, RedGoalDistance, BlueGoalDistance, Storage, Discs, Scanner, RollerTracker, vexcode_brain_precision\n    # Turns and moves to input coordinates\n    if Seek_Intake_X_Y_FireDiscs_Pickup__FireDiscs:\n        # If you are firing discs, finds distances to both goals and set variables equal to the distances\n        RedGoalDistance = math.sqrt(math.fabs(gps.x_position(INCHES) - 54) * math.fabs(gps.x_position(INCHES) - 54) + math.fabs(gps.y_position(INCHES) - 54) * math.fabs(gps.y_position(INCHES) - 54))\n        BlueGoalDistance = math.sqrt(math.fabs(gps.x_position(INCHES) - -54) * math.fabs(gps.x_position(INCHES) - -54) + math.fabs(gps.y_position(INCHES) - -54) * math.fabs(gps.y_position(INCHES) - -54))\n        if RedGoalDistance > BlueGoalDistance:\n            # If blue goal is closer, turns to goal and sets speed of intake to account for distance.\n            Turn_X_Y_Aim(-54, -54, 1)\n            intake_motor_group.set_velocity(((115 - 0.981 * BlueGoalDistance) + 0.0073 * (BlueGoalDistance * BlueGoalDistance)), PERCENT)\n        elif BlueGoalDistance > RedGoalDistance:\n            # If red goal is closer, turns to goal and sets speed of intake to account for distance.\n            Turn_X_Y_Aim(54, 54, 1)\n            intake_motor_group.set_velocity(((115 - 0.981 * RedGoalDistance) + 0.0073 * (RedGoalDistance * RedGoalDistance)), PERCENT)\n        else:\n            # Defaults to blue goal if both are the same distance\n            Turn_X_Y_Aim(-54, -54, 1)\n            intake_motor_group.set_velocity(((115 - 0.981 * BlueGoalDistance) + 0.0073 * (BlueGoalDistance * BlueGoalDistance)), PERCENT)\n        # Spins intake to fire all discs\n        intake_motor_group.spin_for(REVERSE, 120, DEGREES, wait=True)\n    else:\n        # If not firing, turn to input coordinates.\n        Turn_X_Y_Aim(Seek_Intake_X_Y_FireDiscs_Pickup__X, Seek_Intake_X_Y_FireDiscs_Pickup__Y, 0)\n        if Seek_Intake_X_Y_FireDiscs_Pickup__Pickup > 0:\n            # If you are intaking discs, move to slightly before the inputted coordinates and intake discs.\n            drivetrain.drive_for(FORWARD, (math.sqrt((gps.x_position(INCHES) - Seek_Intake_X_Y_FireDiscs_Pickup__X) * (gps.x_position(INCHES) - Seek_Intake_X_Y_FireDiscs_Pickup__X) + (gps.y_position(INCHES) - Seek_Intake_X_Y_FireDiscs_Pickup__Y) * (gps.y_position(INCHES) - Seek_Intake_X_Y_FireDiscs_Pickup__Y)) - 8), INCHES, wait=True)\n            Intake__(Seek_Intake_X_Y_FireDiscs_Pickup__Pickup)\n        else:\n            # Move to inputted coordinates\n            drivetrain.drive_for(FORWARD, math.sqrt((gps.x_position(INCHES) - Seek_Intake_X_Y_FireDiscs_Pickup__X) * (gps.x_position(INCHES) - Seek_Intake_X_Y_FireDiscs_Pickup__X) + (gps.y_position(INCHES) - Seek_Intake_X_Y_FireDiscs_Pickup__Y) * (gps.y_position(INCHES) - Seek_Intake_X_Y_FireDiscs_Pickup__Y)), INCHES, wait=True)\n\ndef Intake__(Intake_____):\n    global Angle, AimAdjust, RedGoalDistance, BlueGoalDistance, Storage, Discs, Scanner, RollerTracker, vexcode_brain_precision\n    # Sets intake speed to maximum\n    intake_motor_group.set_velocity(100, PERCENT)\n    if Intake_____ > 0:\n        # If the inputted intake is over 0\n        if Storage + Intake_____ == 3 or Storage + Intake_____ < 3:\n            # If the inputted value added to the current number of discs stored is equal to or less than 3,\n            # turn the intake 30 degrees a number of times equal to the inputted number\n            intake_motor_group.spin_for(REVERSE, (30 * Intake_____), DEGREES, wait=True)\n        else:\n            # If the inputted value added to the current number of discs stored is greater than 3,\n            # only intake the maximum number that can be stored.\n            intake_motor_group.spin_for(REVERSE, (30 * (3 - Storage)), DEGREES, wait=True)\n\ndef ClearCorner():\n    global Angle, AimAdjust, RedGoalDistance, BlueGoalDistance, Storage, Discs, Scanner, RollerTracker, vexcode_brain_precision\n    if gps.x_position(INCHES) < -36 and 36 < gps.y_position(INCHES) and RollerTracker[1 - 1] == 0:\n        # Conditional uses robot GPS sensor to check if its in the general area of the upper left corner\n        drivetrain.stop()\n        # Lines the robot up directly across from both rollers\n        Seek_Intake_X_Y_FireDiscs_Pickup(-35, 35, False, 0)\n        # Actually does the rollers\n        drivetrain.turn_to_heading(180, DEGREES, wait=True)\n        drivetrain.drive_for(REVERSE, 23.25, INCHES, wait=True)\n        intake_motor_group.spin_for(FORWARD, 40, DEGREES, wait=True)\n        drivetrain.drive_for(FORWARD, 11, INCHES, wait=True)\n        drivetrain.turn_to_heading(90, DEGREES, wait=True)\n        drivetrain.drive_for(REVERSE, 23.25, INCHES, wait=True)\n        intake_motor_group.spin_for(FORWARD, 40, DEGREES, wait=True)\n        drivetrain.drive_for(FORWARD, 11, INCHES, wait=True)\n        # Declares the roller group as done in the tracker list\n        RollerTracker[1 - 1] = 1\n    elif 36 < gps.x_position(INCHES) and gps.y_position(INCHES) < -36 and RollerTracker[2 - 1] == 0:\n        # Conditional uses robot GPS sensor to check if its in the general area of the lower right corner\n        drivetrain.stop()\n        # Lines the robot up directly across from both rollers\n        Seek_Intake_X_Y_FireDiscs_Pickup(35, -35, False, 0)\n        # Actually does the rollers\n        drivetrain.turn_to_heading(0, DEGREES, wait=True)\n        drivetrain.drive_for(REVERSE, 23.25, INCHES, wait=True)\n        intake_motor_group.spin_for(FORWARD, 40, DEGREES, wait=True)\n        drivetrain.drive_for(FORWARD, 11, INCHES, wait=True)\n        drivetrain.turn_to_heading(270, DEGREES, wait=True)\n        drivetrain.drive_for(REVERSE, 23.25, INCHES, wait=True)\n        intake_motor_group.spin_for(FORWARD, 40, DEGREES, wait=True)\n        drivetrain.drive_for(FORWARD, 11, INCHES, wait=True)\n        # Declares the roller group as odne in the tracker list\n        RollerTracker[2 - 1] = 1\n    else:\n        break\n\ndef Scan_Seek_Pickup(Scan_Seek_Pickup__Pickup):\n    global Angle, AimAdjust, RedGoalDistance, BlueGoalDistance, Storage, Discs, Scanner, RollerTracker, vexcode_brain_precision\n    # This function searches for nearby disks on the field, and picks up the request # of disks\n    # The function uses a Scanner list that stores data in relation to where the found object is\n    drivetrain.set_rotation(0, DEGREES)\n    drivetrain.turn_for(RIGHT, 360, DEGREES, wait=False)\n    # We use just under 360 degrees to ensure it doesn't go over the angle\n    while not drivetrain.rotation(DEGREES) > 359.999999:\n        if bottom_distance.is_object_detected():\n            if bottom_distance.object_distance(INCHES) < 24:\n                # Conditions check if the BottomDistance Sensor found an object and if it was within 24 inches\n                drivetrain.stop()\n                # Scanner list takes note of the internal GPS rotation position\n                Scanner[1 - 1] = gps.heading()\n                # Scanner list takes note of distance to the detected object\n                Scanner[2 - 1] = bottom_distance.object_distance(INCHES)\n                break\n        wait(5, MSEC)\n    drivetrain.stop()\n    # Uses information gathered from sensors to drive just close enough to the detected object\n    drivetrain.turn_to_heading(Scanner[1 - 1], DEGREES, wait=True)\n    drivetrain.drive_for(FORWARD, (3 + Scanner[2 - 1]), INCHES, wait=True)\n    # Calls the Pickup method to pick up the disks\n    Intake__(Scan_Seek_Pickup__Pickup)\n\ndef Turn_X_Y_Aim(Turn_X_Y_Aim__X, Turn_X_Y_Aim__Y, Turn_X_Y_Aim__Aim):\n    global Angle, AimAdjust, RedGoalDistance, BlueGoalDistance, Storage, Discs, Scanner, RollerTracker, vexcode_brain_precision\n    # X defines the X-Value of the point you wish to turn to. Y defines the Y-Value of said point.\n    # Aim defines whether you are aiming or not, with 1 meaning you are and 0 meaning you are not.\n    # If aiming, the robot turns the opposite heading it would have so that it back is facing the input\n    # coordinates instead of the front.\n    Angle = math.atan(math.fabs(gps.y_position(INCHES) - Turn_X_Y_Aim__Y) / math.fabs(gps.x_position(INCHES) - Turn_X_Y_Aim__X)) / math.pi * 180\n    AimAdjust = Turn_X_Y_Aim__Aim * 180\n    if Turn_X_Y_Aim__X > gps.x_position(INCHES) and Turn_X_Y_Aim__Y > gps.y_position(INCHES):\n        # If the inputted coordinates are in the 1st quadrant relative to the robot, turn to the inputted\n        # coordinates, accounting for the quadrant.\n        drivetrain.turn_to_heading(((90 + AimAdjust) - Angle), DEGREES, wait=True)\n    elif gps.x_position(INCHES) > Turn_X_Y_Aim__X and Turn_X_Y_Aim__Y > gps.y_position(INCHES):\n        # If the inputted coordinates are in the 2nd quadrant relative to the robot, turn to the inputted\n        # coordinates, accounting for the quadrant.\n        drivetrain.turn_to_heading(((270 - AimAdjust) + Angle), DEGREES, wait=True)\n    elif gps.x_position(INCHES) > Turn_X_Y_Aim__X and gps.y_position(INCHES) > Turn_X_Y_Aim__Y:\n        # If the inputted coordinates are in the 3rd quadrant relative to the robot, turn to the inputted\n        # coordinates, accounting for the quadrant.\n        drivetrain.turn_to_heading(((270 - AimAdjust) - Angle), DEGREES, wait=True)\n    elif Turn_X_Y_Aim__X > gps.x_position(INCHES) and gps.y_position(INCHES) > Turn_X_Y_Aim__Y:\n        # If the inputted coordinates are in the 4th quadrant relative to the robot, turn to the inputted\n        # coordinates, accounting for the quadrant.\n        drivetrain.turn_to_heading(((90 + AimAdjust) + Angle), DEGREES, wait=True)\n    elif Turn_X_Y_Aim__X == gps.x_position(INCHES) and Turn_X_Y_Aim__Y > gps.y_position(INCHES):\n        # If the inputted coordinates are directly \"upward\" from the robot, turn \"upward\"\n        drivetrain.turn_to_heading(AimAdjust, DEGREES, wait=True)\n    elif Turn_X_Y_Aim__X == gps.x_position(INCHES) and gps.y_position(INCHES) > Turn_X_Y_Aim__Y:\n        # If the inputted coordinates are directly \"downward\" from the robot, turn \"downward\"\n        drivetrain.turn_to_heading((180 - AimAdjust), DEGREES, wait=True)\n    elif Turn_X_Y_Aim__Y == gps.y_position(INCHES) and gps.x_position(INCHES) > Turn_X_Y_Aim__X:\n        # If the inputted coordinates are directly \"left\" from the robot, turn \"left\"\n        drivetrain.turn_to_heading((270 - AimAdjust), DEGREES, wait=True)\n    else:\n        # If the inputted coordinates are directly \"right\" from the robot, turn \"right\"\n        drivetrain.turn_to_heading((90 + AimAdjust), DEGREES, wait=True)\n\ndef when_started1():\n    global Angle, AimAdjust, RedGoalDistance, BlueGoalDistance, Storage, Discs, Scanner, RollerTracker, vexcode_brain_precision\n    # This function continuously runs while the intake isn't spinning for the whole match\n    while not intake_motor_group.is_spinning():\n        while True:\n            if top_line_tracker.reflectivity(PERCENT) > 80:\n                # Disc in Top Spot, updates status in Disks list tracker\n                Discs[1 - 1] = 1\n            else:\n                Discs[1 - 1] = 0\n            if middle_line_tracker.reflectivity(PERCENT) > 80:\n                # Disc in Middle Spot, updates status in Disks list tracker\n                Discs[2 - 1] = 1\n            else:\n                Discs[2 - 1] = 0\n            if bottom_line_tracker.reflectivity(PERCENT) > 80:\n                # Disc in Bottom Spot, updates status in Disks list tracker\n                Discs[3 - 1] = 1\n            else:\n                Discs[3 - 1] = 0\n            # Updates a different lists so the load variable is updated and the intake function works\n            Storage = Discs[1 - 1] + (Discs[2 - 1] + Discs[3 - 1])\n            wait(5, MSEC)\n        wait(5, MSEC)\n\ndef when_started2():\n    global Angle, AimAdjust, RedGoalDistance, BlueGoalDistance, Storage, Discs, Scanner, RollerTracker, vexcode_brain_precision\n    # Master function that controls all movement and sub functions\n    # Resets velocities of all components and 0s the sensors\n    vexcode_brain_precision = 3\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n    drivetrain.set_heading(gps.heading(), DEGREES)\n    intake_motor_group.set_velocity(100, PERCENT)\n    # Resets the intake\n    if Storage > 0:\n        intake_motor_group.spin_for(FORWARD, (120 - Storage * 30), DEGREES, wait=True)\n    # Loop to look for disks and fire them for the first 40 seconds of a match\n    while not 45 < brain.timer.time(SECONDS):\n        # Function calls for 2 disks to always be gathered in the intake and then fired\n        Scan_Seek_Pickup(2)\n        Seek_Intake_X_Y_FireDiscs_Pickup(0, 0, True, 0)\n        wait(5, MSEC)\n    # Code moves the robot into the upper corner first\n    Seek_Intake_X_Y_FireDiscs_Pickup(-40, 40, False, 0)\n    # Robot performs upper corner\n    ClearCorner()\n    # Code moves the robot into the lower corner second\n    Seek_Intake_X_Y_FireDiscs_Pickup(40, -40, False, 0)\n    # Robot performs lower corner, parks on 4 tiles\n    ClearCorner()\n\nvr_thread(when_started2)\nvr_thread(when_started1)\n","textLanguage":"python","rconfig":[],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"","minVersion":"2.4.0","fileFormat":"1.0.1","icon":"","targetBrainGen":"First","target":"Virtual","virtualSkillsYear":"2023"}